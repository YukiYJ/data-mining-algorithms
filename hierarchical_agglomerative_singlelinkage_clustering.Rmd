---
title: "Hierarchical Agglomerative Single Linkage Clustering Simulation"
author: "MA Mingyu 14110562D"
date: "4/5/2017"
output: pdf_document
---
#COMP4433 Assignment 2 Question 3d
##derek.ma@connect.polyu.hk [derek.ma](http://derek.ma)

#Set Up
Import data, delete first column, set initial cluster centers to first two records and set k is equal to 2.
```{r setup, include=TRUE}
library(dplyr)
#PREPARE DATA IN USE
data <- read.csv("~/Google Drive/_DM/2_Assignments/Ass2/data_q3.csv", stringsAsFactors = FALSE)
#delete first column for this specific case becasue it is not a data record
data <- data[,2:length(colnames(data))]
```

```{r testData}
library(dplyr)
data <- data.frame(
  x=c(0.4,0.22,0.35,0.26,0.08,0.45),
  y=c(0.53,0.38,0.32,0.19,0.41,0.3)
    )
```

```{r preprocessing}
#Normalization
min1 <- min(data$B)
max1 <- max(data$B)
min2 <- min(data$C)
max2 <- max(data$C)
min3 <- min(data$D)
max3 <- max(data$D)
min4 <- min(data$E)
max4 <- max(data$E)
min5 <- min(data$F)
max5 <- max(data$F)
min6 <- min(data$G)
max6 <- max(data$G)

data_normalized <- data %>%
  mutate(BN = (B - min1)/(max1-min1)) %>%
  mutate(CN = (C - min2)/(max2-min2)) %>%
  mutate(DN = (D - min3)/(max3-min3)) %>%
  mutate(EN = (E - min4)/(max4-min4)) %>%
  mutate(FN = (F - min5)/(max5-min5)) %>%
  mutate(GN = (G - min6)/(max6-min6))

data_normalized <- data_normalized[,c(7,8,9,10,11,12)]
colnames(data_normalized) <- c("B","C","D","E","F","G")
data <- data_normalized
```

```{r setParas}
# Create initial proximity matrix
proximityMatrix <- data.frame(matrix(NA, ncol = nrow(data), nrow = nrow(data)))
colnames(proximityMatrix) <- (1:nrow(data))
# Create a data frame to save all clusters
clusters <- data.frame(matrix(NA, ncol = nrow(data), nrow = nrow(data)))
colnames(clusters) <- (1:nrow(data))
colnames(clusters) <- paste("cluster", colnames(clusters), sep = "_")
clusters[1,] <- 1:nrow(data)
```

```{r distance,include=FALSE}
distance <- function(vector1, vector2){
  #Euclidean distance
  #Input: two vectors of data with same length
  #Input example: c(1,2,3); c(2,3,4)
  count <- 0
  for (i in 1:length(vector1)){
    count = count + (vector1[i] - vector2[i])^2
  }
  count^(1/2)
}
```

# Create Initial Proximity Matrix
```{r initialProximityMatrix}
updateProximity <- function(clustersData, objectsData, proximityData){
  newProximityData <- proximityData
  for (irow in 1:nrow(clustersData)){
    for (icol in irow:nrow(clustersData)){
      # For each pair of clusters
      currentMinDist <- 0
      for (pointClu1 in 1:sum(!is.na(clustersData[,irow]))){
        for (pointClu2 in 1:sum(!is.na(clustersData[,icol]))){
          # For each pair of points
          dist_value <- distance(
            as.numeric(objectsData[clustersData[pointClu1,irow],]),
            as.numeric(objectsData[clustersData[pointClu2,icol],])
          )
          if (dist_value < currentMinDist || currentMinDist == 0){
            currentMinDist <- dist_value
          }
        }
      }
      # save min distance between these two clusters
      newProximityData[irow,icol] <- currentMinDist
    }
  }
  newProximityData
}
```

```{r test1}
temp <- updateProximity(clusters,data,proximityMatrix)
```

# Round1
## Merge the Closest Two Clusters
```{r merge1}
mydf[, colSums(mydf != "") != 0]
```
## Update Proximity Matrix
## Check Termination Criterion 

